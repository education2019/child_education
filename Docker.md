### 一、什么是Docker

> 简介：Docker是一种容器技术，但是Docker本身并不是容器，他是创建容器的工具，是应用容器引擎
> 	口号1："**Build, Ship and Run**":搭建，发送，运行三板斧
>
> ​	口号2：**“Build once，Run anywhere“**：搭建一次，到处运行
>
> ​	小故事：小猪佩琪特别喜欢睡觉，可是生活水平要求比较高，必须要有房子才睡得着，于是他就去砍树，建房子，制做床，一顿猛如虎的操作之后，盖好了一个房子，过了一段时间，佩琪觉得世界那么大想去看看了，可是它又不想去一个新地方再盖一个房子，应为需要再次砍树，盖房子，这是候就蹦出来一个白胡子的老爷爷，它给了佩琪一个法宝，他可以使用法宝将房子复制一份，做成镜像，把它装进裤兜，每当佩琪到一个地方，就从法宝里面的镜像复制一个房子，拎包入住
>
>  
>
> 三大核心概念：
>
> ​	镜像：Image     -> 法宝中的本体
>
> ​	容器：Container      ->从法宝中复制出来的房子
>
> ​	仓库：Repository          -> 法宝就是仓库
>
> 说白了，Docker镜像，就是一个特殊的文件系统。他除了提供容器运行是所需要的程序、库、资源、配置文件等之外，还包含了一些为运行是准备的一些配置参数（比如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变；也就是说每次复制出来的房子都是一样的，谁住谁就得填购日用品
>
> ​	但是还有别的人被神仙指导做了不同的镜像，北极一哥们儿做了个冰屋，海底的美人鱼盖了水晶宫，鲲鹏修了个悬空楼...他们都吧房子做成了镜像，这样鲲鹏如水找不到住的地方就可以用水晶宫的镜像，美人鱼看上了北极的小哥哥就可以吧冰屋拿过来用，是不是美滋滋；于是就变成了一个打的公共仓库
>
> ​	Docker Registry服务：负责对镜像进行管理；最长使用的Registry公开服务，是官方的Docker Hub，也是默认的Registry，并拥有大量的高质量的官方镜像
>
> ​	但是Docker应用与具体的业务实现，编排、管理、调度等各个方面都是存在困难的，所以大家迫切需要一套管理系统，对Docker容器进行更高级更灵活的管理，2014年6月，Google发布了K8S

### 二、K8S

> K8S，基于容器的集群管理平台，全程是kubernetes，数字8指的是中间的8个字符
>
> 一个K8S系统通常称为一个K8S集群：主要包括两个部分

![](/home/anthony/桌面/13382653-7abbf013cb556965.png)

> 一个Master节点(主节点)：管理和控制
>
> 一群Node节点(计算节点)：工作负载几点，里面是具体的容器

2.1Master节点

![](/home/anthony/桌面/13382653-c7872d6a360d9a36.png)

> API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。
>
> Scheduler负责对集群内部的资源进行调度，相当于“调度室”。
>
> Controller manager负责管理控制器，相当于“大总管”。

#### 2.2 Node节点

![](/home/anthony/桌面/13382653-80f2268ac078fbc6.jpeg)

> Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个**Service**的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。
>
> Docker，不用说了，创建容器的。
>
> Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。
>
> Kube-proxy，主要负责为Pod对象提供代理。
>
> Fluentd，主要负责日志收集、存储与查询。

### 二、Docker常用场景

> 1. web应用的自动化打包和发布;
> 2. 自动化测试和持续集成、发布；
> 3. 在服务型环境中部署和调整数据库或其他的后台应用；
> 4. 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境

### 三、Docker的准备工作

> Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演者docker服务端的远程控制器，用来空值docker的服务端进程，大部分情况下，docker服务端和客户端运行在一台机器上。

```python
#Docker常用命令
#docker version : 查看docker的版本【一般包含客户端与服务端】
docker version
#docker search 镜像名 ：搜索镜像名的镜像
docker search tutorial
#部分比较特殊的镜像，比如ubuntu这类基础镜像，经过官方的验证，值得新人，可以直接用镜像名来检索到
#docker pull 用户名/镜像名 : 下载镜像
docker pull learn/tutorial
#docker run 镜像名 镜像所要执行的命令
docker run learn/tutorial echo "HELLO WORLD"
#输出:HELLO WORLD
#docker ps -l :获得安装玩ping命令之后的容器的id
docker ps -l
#docker commit id前几位，该命令执行完毕后，会返回新版本镜像的id号
docker commit 797 learn/ping
#运行新的镜像
docker run learn/ping ping www.baidu.com

docker ps：可以查看所有正在运行中的容器列表
docker inspect:可以查看更详细的关于某一个容器的信息，其后面跟的是镜像ID的前面的部分
```

#### 五大核心算法简介

> **递归算法**：直接或者间接不断反复调用自身来达到解决问题的方法。要求原始问题可以分解为相同问题的子问题。
>
> **分治算法**的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。 
>
> **动态规划过程**是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 
>
> **所谓贪心算法**是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法没有固定的算法框架，算法设计的**关键是贪心策略**的选择，贪心策略使用的前提是局部最优能导致全局最优。
>
> **回溯法，**又称为试探法，按**选优条件**向前不断搜索，以达到目标。但是当探索到某一步时，如果发现原先选择并不优或达不到目标，就会退回一步重新选择，这种达不到目的就退回再走的算法称为回溯法。 
>
> **阿姆达尔定律**是计算机系统设计的重要定量原理之一，于1967年由IBM360[系列机](https://baike.so.com/doc/485014.html)的主要设计者阿姆达尔首先提出。该定律是指：系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。阿姆达尔定律实际上定义了采取增强（加速）某部分功能处理的措施后可获得的性能改进或执行时间的[加速比](https://baike.so.com/doc/6970932.html)。
>
> **所谓“核心算法”，**就是你始终揪住它不放松的东西，做任何事都是使用这个“核心算法”，在任何选择关头，不管别人怎么说，怎么看，都用这个原理做决策。
>
> 学习上，这也想学那也想学，最后可能什么都不精；职场上，什么都想抓住，往往最后白忙一场。在我们的人生道路上，诱惑实在太多，就怕走着走着，突然一抬头，发现自己已经偏离了目标路线。
>
> 要想在某领域做出成就，首先就是找到符合时宜的正确“核心算法”，其次就是重复地做，笨笨地坚持往下做，让自己的优势指数级积累。